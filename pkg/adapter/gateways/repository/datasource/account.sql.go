// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: account.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const createAccounts = `-- name: CreateAccounts :one
INSERT INTO
    accounts (
        account_id,
        username,
        icon,
        explanatory_text,
        locate_id,
        rate,
        user_id,
        show_locate,
        show_rate
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    ) RETURNING account_id, user_id, username, icon, explanatory_text, locate_id, rate, charactor, show_locate, show_rate, create_at, update_at, is_delete
`

type CreateAccountsParams struct {
	AccountID       string         `json:"account_id"`
	Username        string         `json:"username"`
	Icon            sql.NullString `json:"icon"`
	ExplanatoryText sql.NullString `json:"explanatory_text"`
	LocateID        int32          `json:"locate_id"`
	Rate            int32          `json:"rate"`
	UserID          string         `json:"user_id"`
	ShowLocate      bool           `json:"show_locate"`
	ShowRate        bool           `json:"show_rate"`
}

func (q *Queries) CreateAccounts(ctx context.Context, arg CreateAccountsParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccounts,
		arg.AccountID,
		arg.Username,
		arg.Icon,
		arg.ExplanatoryText,
		arg.LocateID,
		arg.Rate,
		arg.UserID,
		arg.ShowLocate,
		arg.ShowRate,
	)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.UserID,
		&i.Username,
		&i.Icon,
		&i.ExplanatoryText,
		&i.LocateID,
		&i.Rate,
		&i.Charactor,
		&i.ShowLocate,
		&i.ShowRate,
		&i.CreateAt,
		&i.UpdateAt,
		&i.IsDelete,
	)
	return i, err
}

const deleteAccounts = `-- name: DeleteAccounts :one
UPDATE
    accounts
SET
    is_delete = true
WHERE
    account_id = $1 RETURNING account_id, user_id, username, icon, explanatory_text, locate_id, rate, charactor, show_locate, show_rate, create_at, update_at, is_delete
`

func (q *Queries) DeleteAccounts(ctx context.Context, accountID string) (Account, error) {
	row := q.db.QueryRowContext(ctx, deleteAccounts, accountID)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.UserID,
		&i.Username,
		&i.Icon,
		&i.ExplanatoryText,
		&i.LocateID,
		&i.Rate,
		&i.Charactor,
		&i.ShowLocate,
		&i.ShowRate,
		&i.CreateAt,
		&i.UpdateAt,
		&i.IsDelete,
	)
	return i, err
}

const getAccountsByEmail = `-- name: GetAccountsByEmail :one
SELECT
    account_id,
    username,
    icon,
    explanatory_text,
    locate_id,
    rate,
    user_id,
    show_locate,
    show_rate,
    create_at,
    update_at
FROM
    accounts
WHERE
    user_id = (
        SELECT user_id FROM users WHERE email = $1
    ) AND is_delete = false
`

type GetAccountsByEmailRow struct {
	AccountID       string         `json:"account_id"`
	Username        string         `json:"username"`
	Icon            sql.NullString `json:"icon"`
	ExplanatoryText sql.NullString `json:"explanatory_text"`
	LocateID        int32          `json:"locate_id"`
	Rate            int32          `json:"rate"`
	UserID          string         `json:"user_id"`
	ShowLocate      bool           `json:"show_locate"`
	ShowRate        bool           `json:"show_rate"`
	CreateAt        time.Time      `json:"create_at"`
	UpdateAt        time.Time      `json:"update_at"`
}

func (q *Queries) GetAccountsByEmail(ctx context.Context, email string) (GetAccountsByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountsByEmail, email)
	var i GetAccountsByEmailRow
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Icon,
		&i.ExplanatoryText,
		&i.LocateID,
		&i.Rate,
		&i.UserID,
		&i.ShowLocate,
		&i.ShowRate,
		&i.CreateAt,
		&i.UpdateAt,
	)
	return i, err
}

const getAccountsByID = `-- name: GetAccountsByID :one
SELECT
    account_id,
    username,
    icon,
    explanatory_text,
    locate_id,
    rate,
    user_id,
    show_locate,
    show_rate,
    create_at,
    update_at
FROM
    accounts
WHERE
    account_id = $1 AND is_delete = false
`

type GetAccountsByIDRow struct {
	AccountID       string         `json:"account_id"`
	Username        string         `json:"username"`
	Icon            sql.NullString `json:"icon"`
	ExplanatoryText sql.NullString `json:"explanatory_text"`
	LocateID        int32          `json:"locate_id"`
	Rate            int32          `json:"rate"`
	UserID          string         `json:"user_id"`
	ShowLocate      bool           `json:"show_locate"`
	ShowRate        bool           `json:"show_rate"`
	CreateAt        time.Time      `json:"create_at"`
	UpdateAt        time.Time      `json:"update_at"`
}

func (q *Queries) GetAccountsByID(ctx context.Context, accountID string) (GetAccountsByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountsByID, accountID)
	var i GetAccountsByIDRow
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Icon,
		&i.ExplanatoryText,
		&i.LocateID,
		&i.Rate,
		&i.UserID,
		&i.ShowLocate,
		&i.ShowRate,
		&i.CreateAt,
		&i.UpdateAt,
	)
	return i, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT
    account_id,
    username,
    icon,
    (
        SELECT
            name
        FROM
            locates
        WHERE
            locate_id = accounts.locate_id
    ) as locate,
    rate,
    show_locate,
    show_rate
FROM
    accounts
WHERE
    username LIKE $1 AND is_delete = false
LIMIT
    $2 OFFSET $3
`

type ListAccountsParams struct {
	Username string `json:"username"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

type ListAccountsRow struct {
	AccountID  string         `json:"account_id"`
	Username   string         `json:"username"`
	Icon       sql.NullString `json:"icon"`
	Locate     string         `json:"locate"`
	Rate       int32          `json:"rate"`
	ShowLocate bool           `json:"show_locate"`
	ShowRate   bool           `json:"show_rate"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]ListAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccounts, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountsRow{}
	for rows.Next() {
		var i ListAccountsRow
		if err := rows.Scan(
			&i.AccountID,
			&i.Username,
			&i.Icon,
			&i.Locate,
			&i.Rate,
			&i.ShowLocate,
			&i.ShowRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccounts = `-- name: UpdateAccounts :one
UPDATE
    accounts
SET
    username = $2,
    icon = $3,
    explanatory_text = $4,
    locate_id = $5,
    rate = $6,
    show_locate = $7,
    show_rate = $8
WHERE
    account_id = $1 RETURNING account_id, user_id, username, icon, explanatory_text, locate_id, rate, charactor, show_locate, show_rate, create_at, update_at, is_delete
`

type UpdateAccountsParams struct {
	AccountID       string         `json:"account_id"`
	Username        string         `json:"username"`
	Icon            sql.NullString `json:"icon"`
	ExplanatoryText sql.NullString `json:"explanatory_text"`
	LocateID        int32          `json:"locate_id"`
	Rate            int32          `json:"rate"`
	ShowLocate      bool           `json:"show_locate"`
	ShowRate        bool           `json:"show_rate"`
}

func (q *Queries) UpdateAccounts(ctx context.Context, arg UpdateAccountsParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccounts,
		arg.AccountID,
		arg.Username,
		arg.Icon,
		arg.ExplanatoryText,
		arg.LocateID,
		arg.Rate,
		arg.ShowLocate,
		arg.ShowRate,
	)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.UserID,
		&i.Username,
		&i.Icon,
		&i.ExplanatoryText,
		&i.LocateID,
		&i.Rate,
		&i.Charactor,
		&i.ShowLocate,
		&i.ShowRate,
		&i.CreateAt,
		&i.UpdateAt,
		&i.IsDelete,
	)
	return i, err
}

const updateRateByID = `-- name: UpdateRateByID :one
UPDATE
    accounts
SET    
    rate = $2
WHERE
    account_id = $1 RETURNING account_id, user_id, username, icon, explanatory_text, locate_id, rate, charactor, show_locate, show_rate, create_at, update_at, is_delete
`

type UpdateRateByIDParams struct {
	AccountID string `json:"account_id"`
	Rate      int32  `json:"rate"`
}

func (q *Queries) UpdateRateByID(ctx context.Context, arg UpdateRateByIDParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateRateByID, arg.AccountID, arg.Rate)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.UserID,
		&i.Username,
		&i.Icon,
		&i.ExplanatoryText,
		&i.LocateID,
		&i.Rate,
		&i.Charactor,
		&i.ShowLocate,
		&i.ShowRate,
		&i.CreateAt,
		&i.UpdateAt,
		&i.IsDelete,
	)
	return i, err
}
